// Automatically generated by Interoptopus.
#pragma warning disable 1591

#pragma warning disable 0105
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Oicana.Interop;
#pragma warning restore 0105

namespace Oicana.Interop
{
    internal static partial class OicanaFfiInternal
    {
        public const string NativeLib = "oicana_csharp";

        static OicanaFfiInternal()
        {
        }


        /// Compile the template with the given identifier
        ///
        /// This method requires a previous successful call to [`unsafe_register_template()`].
        /// Check if the returned buffer is an error before interpreting the content.
        ///
        /// # Safety
        ///
        /// The caller is responsible for ensuring that the provided
        /// `template`, `input`, and `banner` pointers are valid and non-null, and that
        /// the `input` and `banner` data is properly aligned and initialized.
        ///
        /// Additionally, the caller must ensure that the blob input buffers are not modified
        /// concurrently while this function is executing.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "unsafe_compile_template")]
        public static extern Buffer unsafe_compile_template(string template, SliceFfiJsonInput json_inputs, SliceFfiBlobInput blob_inputs, CompilationOptions compilation_options);

        /// Compile the given template once.
        ///
        /// This method does not do any caching. If you want faster compilations,
        /// prepare your templates by registering them with [`unsafe_register_template`]
        /// and then calling [`unsafe_compile_template`] with the same identifier.
        ///
        /// # Safety
        ///
        /// The caller is responsible for ensuring that the provided
        /// `files`, `json_inputs`, and `blob_inputs` pointers are valid and non-null,
        /// and that all data is properly aligned and initialized.
        ///
        /// Additionally, the caller must ensure that no inputs are modified
        /// concurrently while this function is executing.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "unsafe_compile_template_once")]
        public static extern Buffer unsafe_compile_template_once(Buffer files, SliceFfiJsonInput json_inputs, SliceFfiBlobInput blob_inputs, CompilationOptions compilation_options);

        /// Register a template for the given identifier
        ///
        /// After a successful call to this method, use [`unsafe_compile_template()`] for compiling
        /// with improved performance.
        ///
        /// # Safety
        ///
        /// The caller is responsible for ensuring that the provided
        /// `template`, `input`, and `banner` pointers are valid and non-null, and that
        /// the `input` and `banner` data is properly aligned and initialized.
        ///
        /// Additionally, the caller must ensure that no inputs are modified
        /// concurrently while this function is executing.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "unsafe_register_template")]
        public static extern Buffer unsafe_register_template(string template, Buffer files, SliceFfiJsonInput json_inputs, SliceFfiBlobInput blob_inputs, CompilationOptions compilation_options);

        /// Load the inputs of the given template.
        ///
        /// This method requires a previous successful call to [`unsafe_register_template`].
        /// Check if the returned buffer is an error before interpreting the content.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "inputs")]
        public static extern Buffer inputs(string template);

        /// Load the source at the given path in the template.
        ///
        /// This method requires a previous successful call to [`unsafe_register_template`].
        /// Check if the returned buffer is an error before interpreting the content.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "get_source")]
        public static extern Buffer get_source(string template, string path);

        /// Load the file at the given path in the template.
        ///
        /// This method requires a previous successful call to [`unsafe_register_template`].
        /// Check if the returned buffer is an error before interpreting the content.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "get_file")]
        public static extern Buffer get_file(string template, string path);

        /// Frees a buffer allocated by `compile_template`.
        ///
        /// # Safety
        ///
        /// This function is unsafe because it assumes the following:
        ///
        /// 1. The [`Buffer::data`] pointer must be non-null and valid. It must point to memory allocated by
        ///    Rust which was not previously freed.
        ///
        /// 2. No other pointers to the memory should be used after this function has been called.
        ///
        /// 3. This function must be called from a context where it is safe to free memory, ensuring
        ///    no concurrent accesses.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "unsafe_free_buffer")]
        public static extern void unsafe_free_buffer(Buffer buffer);

        /// Clear the specified template from the internal cache.
        ///
        /// This method requires a previous successful call to [`unsafe_register_template`].
        /// Check if the returned buffer is an error before interpreting the content.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "unregister_template")]
        public static extern void unregister_template(string template);

        /// Configure Oicana.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "configure")]
        public static extern Buffer configure(Config config);

    }

    /// The mode of compilation
    public enum CompilationMode
    {
        /// Use development values for inputs if an input is not explicitly set.
        /// If there is no development value, fall back to the default value.
        Development = 0,
        /// If an input is not set, use the default value if available.
        Production = 1,
    }

    /// Formats that an Oicana template can be compiled into.
    public enum CompilationTarget
    {
        /// Render the template to a PDF file.
        ///
        /// The exported standard is PDF/A-3b
        Pdf = 0,
        /// Render the template into a png image.
        ///
        /// The image is not optimized for file size to speed up compilation.
        Png = 1,
        /// Render the template as SVG file.
        Svg = 2,
    }

    /// Formats that the compiled documents can be rendered into.
    public enum DiagnosticColor
    {
        /// No colors in diagnostic output
        None = 0,
        /// ANSI codes for colors in diagnostic output
        Ansi = 1,
    }

    /// Access to a piece of Rust memory.
    ///
    /// If [`Self::error`] is `true`, [`Self::data`] will point to a UTF-8 encoded error message.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    internal partial struct Buffer
    {
        /// Pointer to the beginning of the buffer data.
        public IntPtr data;
        /// Whether this buffer is an error.
        [MarshalAs(UnmanagedType.I1)]
        public bool error;
        /// Length of the buffer data.
        public uint len;
    }

    /// Options for compiling the template
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    internal partial struct CompilationOptions
    {
        /// Formats that an Oicana template can be compiled into.
        public CompilationTarget target;
        /// The mode of compilation
        public CompilationMode mode;
        /// Pixels per pt
        /// Only used for PNG export
        public float px_per_pt;
    }

    /// Oicana Configuration.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    internal partial struct Config
    {
        /// Coloring for diagnostics like warnings and errors
        public DiagnosticColor color;
    }

    /// A collection of string keys with Buffers representing blob inputs
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    internal partial struct FfiBlobInput
    {
        /// Buffer containing the main data of the blob input.
        public Buffer data;
        /// Identifier of the input definition this input value belongs to.
        public string key;
        /// Metadata of the blob input as json.
        public string meta;
    }

    /// A collection of string pairs representing JSON inputs
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    internal partial struct FfiJsonInput
    {
        /// String containing the json payload of this input.
        public string data;
        /// Identifier of the input definition this input value belongs to.
        public string key;
    }

    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    internal partial struct SliceFfiBlobInput
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    internal partial struct SliceFfiBlobInput : IEnumerable<FfiBlobInput>
    {
        public SliceFfiBlobInput(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public SliceFfiBlobInput(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        public FfiBlobInput this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                var size = Marshal.SizeOf(typeof(FfiBlobInput));
                var ptr = new IntPtr(data.ToInt64() + i * size);
                return Marshal.PtrToStructure<FfiBlobInput>(ptr);
            }
        }
        public FfiBlobInput[] Copied
        {
            get
            {
                var rval = new FfiBlobInput[len];
                for (var i = 0; i < (int)len; i++)
                {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int)len;
        public IEnumerator<FfiBlobInput> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    internal partial struct SliceFfiJsonInput
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    internal partial struct SliceFfiJsonInput : IEnumerable<FfiJsonInput>
    {
        public SliceFfiJsonInput(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public SliceFfiJsonInput(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        public FfiJsonInput this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                var size = Marshal.SizeOf(typeof(FfiJsonInput));
                var ptr = new IntPtr(data.ToInt64() + i * size);
                return Marshal.PtrToStructure<FfiJsonInput>(ptr);
            }
        }
        public FfiJsonInput[] Copied
        {
            get
            {
                var rval = new FfiJsonInput[len];
                for (var i = 0; i < (int)len; i++)
                {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int)len;
        public IEnumerator<FfiJsonInput> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }




    public class InteropException<T> : Exception
    {
        public T Error { get; private set; }

        public InteropException(T error) : base($"Something went wrong: {error}")
        {
            Error = error;
        }
    }

}
